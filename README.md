# Proof of Concept for Module Path-based Convention

This is a proof of concept on how a path-based approach can make it
possible to build a C++ project with modules, including consuming C++
modules external to the build system.

This is meant as a side-car to the [Distributing C++ Module
Libraries](https://isocpp.org/files/papers/P2473R0.pdf) paper.

## Invocation

Building out-of-source is important, because the project will need to
create bmi files for whatever modules that were not shipped with a
compatible BMI file.

```
mkdir build && make -C build -f $(pwd)/Makefile
```

## VPATH and the module search path

In order for this to work correctly, we make use of the VPATH feature
of GNU Make, and we make it coincide with the module search path,
meaning that Make itself is capable of resolving the dependency
information and consume whatever bmi is already available, but produce
whatever bmi is necessary.

In this sample project, the module search path is comprised of the
root of the current directory (where bmi files are created), the root
of the repo, where the modules meant as internal to this project, and
the external-modules directory, meant to represent other modules
available in the system.

VPATH is therefore set to the two directories where the local source
code is going to be found as well as the directories where external
modules may be found. Meanwhile the module path is set to include the
current directory ahead of those, as that's where the local builds are
going to be placed.

## Encoding the compatibility in the bmi file name

This allows an important optimization for systems that do use the same
compiler across the board to ship pre-parsed module interfaces. The
name of those files is made as unique as the compiler needs it to be,
and the string is discovered by calling the compiler itself in this
PoC, this is the BMI_UUID variable in the Makefile.

This compatibility id needs to be communicated to the dependency
mapping, such that we can correctly generate the build rules.

## `c++-module-config`

This utility is a proof-of-concept implementation of a tool that knows
how to parse your local non-module code and then identify which
modules it depends on, and then uses the module search path to
identify all the information necessary to parse any internal or
external modules.

This is implemented to demonstrate that a build system would be able
to configure any required build steps from modules that follow this
convention in a straight-forward way that can be easily replicated by
other tools, as long as the module search path is provided.

## `c++-module-makemake`

This utility is a proof-of-concept implementation of a tool that
translates the information generated by `c++-module-config` into a
make-compatible dependency file that can be included by the makefile.

The simple inclusion of `deps.mk`, and the rules to generate it are
sufficient to fully configure the build in this given directory.

# Copyright statement


```
// ----------------------------------------------------------------------------
// Copyright 2021 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
```
